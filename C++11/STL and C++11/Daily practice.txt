#include <iostream>

using namespace std;

template<typename T>
class container
{
    T d;
    public:
    explicit container(T data):d(data)
    {
        
    }
    friend std::ostream& operator<<(std::ostream& os,const container<T>& data)
    {
        return (os<<data.d);
    }
};

int main()
{
    container<int> c(100);
    container<string> a("ABC");
    cout<<c<<" "<<a;

    return 0;
}
---------------
#include <iostream>

using namespace std;
template<typename T>
class shrdPtr
{
    T *p;
    public:
    shrdPtr(T *d):p(d)
    {
        
    }
    ~shrdPtr()
    {
        cout<<"destructor\n";
        delete p;
    }
    T& operator*()
    {
        return *p;
    }
};

int main()
{
    int* p= new int(10);
    shrdPtr<int> sp(p);
    cout<<*p;
    
    *p= 20;
    
    cout<<*p;
    
    return 0;
}
----------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;


int main()
{
    vector<int> v{1,2,3,4,5,6,7,8,9,10};   

    vector<int> out;
    
    copy(begin(v),end(v),ostream_iterator<int>(cout,"+"));
    
    
    copy_if(begin(v),end(v),back_inserter(out),[](int i){return i%2==0;});
    
    
    copy(begin(out),end(out),ostream_iterator<int>(cout," "));

    
    return 0;
}
-----------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;
template<typename T>
void printData(T data)
{
    for(auto a: data)
    {
        cout<<a<<"\n";
    }
}

int main()
{
    vector<int> v{1,2,3,4,5,6,7,8,9,10};   

    vector<int> out;
    
    copy(begin(v),end(v),ostream_iterator<int>(cout,"+"));
    
    
    copy_if(begin(v),end(v),back_inserter(out),[](int i){return i%2==0;});
    
    
    copy(begin(out),end(out),ostream_iterator<int>(cout," "));

    printData<vector<int>>(out);
    
    
    for_each(begin(out),end(out),[](int a){cout<<a;});
    return 0;
}
--------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>

using namespace std;
class student
{
    
    public:
    string name;
    int id;
    student(string iname, int iid):name(iname), id(iid)
    {
        
    }
    
};

int main()
{
   
   student s1("abc",1);
   student s2("efg",2);
   student s3("hij",3);
   
   vector<student> vs1{s1,s2,s3};
   
   
   student a1("abc",1);
   student a2("efg1",2);
   student a3("hij1",3);
   
   vector<student> vs2{a1,a2,a3};
   
   
  std::function<bool(const student&, const student&)> id_equal = [](const student& s1, const student& s2)
  {
      return (s1.id == s2.id);
  };
  
  std::function<bool(const student&, const student&)> compare_all = [](const student& s1, const student& s2)
  {
      return ((s1.id == s2.id) &&
              (s1.name == s2.name));
  };
  
  
//   std::function<bool(const student&, const student&)> id_only =
//                 [](const student& s1,const student& s2){
//                         return s1.id == s2.id;
//                 };
  cout<<boolalpha;
  
  auto e = equal(begin(vs1),end(vs1),begin(vs2),id_equal);
  
  cout<<e<<"\n";
  
  e = equal(begin(vs1),end(vs1),begin(vs2),compare_all);
  
  cout<<e;
   
  return 0;
}
----------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>

using namespace std;

int main()
{
   
  vector<string> fruits{"apple","mango","almond","berry"}; 
  cout<<boolalpha;
  
 
   
//   auto e = find_if(begin(fruits),end(fruits),[](string s){return s=="almond";});
   
//   cout<<*e;

   auto cmpfun = [](string s)
                    {
                        return s=="almond";
                    };
   auto e = find_if(begin(fruits),end(fruits),cmpfun);
   
   cout<<*e;
   return 0;
}
-----------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

using namespace std;



int main()
{
    
    vector<unique_ptr<int>> ptr;
    
    for(int i=0; i<10; i++)
    {
        unique_ptr temp= make_unique<int>();
        *temp = i;
        ptr.push_back(std::move(temp));
    }
    
    for_each(begin(ptr),end(ptr),[](const unique_ptr<int>& p1)
    {
        cout<<*p1<<" ";
    });
    
    vector<unique_ptr<int>> movedPtr;
    
    move(begin(ptr),end(ptr),back_inserter(movedPtr));
    
    cout<<boolalpha<<"\n";
    for_each(begin(movedPtr),end(movedPtr),[](const unique_ptr<int>& p1)
    {
        cout<<(p1 == nullptr)<<"\n";
    });
    return 0;
}

/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <utility>
using namespace std;

void get(int& a)
{
    cout<<"[L value]\n";
}

void get(const int& a)
{
    cout<<"[R value]\n";
}

template<typename T>
void AsperTheArg(T&& x)
{
    cout<<"here\n";
    get(x);
    get(std::forward<T>(x));
}

int main()
{
    
    int a1 =5;
    
    // get(a1);
    
    // get(7);
    
    AsperTheArg(a1);
    AsperTheArg(7);
    return 0;
}
-----------------------------
#include <iostream>
#include <utility>
using namespace std;

void get(int& a)
{
    cout<<"[L value]\n";
}

void get(const int& a)
{
    cout<<"[R value]\n";
}

template<typename A>
void AsperTheArg(A&& x)
{
    cout<<"here\n";
    //get(x);
    get(std::forward<A>(x));
}

int main()
{
    
    int a1 =5;
    
    // get(a1);
    
    // get(7);
    
    AsperTheArg(a1);
    AsperTheArg(7);
    return 0;
}
--------
#include <iostream>

using namespace std;


void get(int& a)
{
    cout<<"[l value]\n";
}
void get(const int& a)
{
    cout<<"[r value]\n";
}

// template<typename T>
// void printData(T&& d)//&& aftet template parameter is known as a universal reference as it is template and type deduction is required.
// {
//     //get(d);
//     get(std::forward<T>(d));
// }


void printData(int&& d)//&& after the specific type is consider as a r-value because no type deduction is needed as it is sepcified here.
{
    //get(d);
    get(std::forward<int>(d));
}

int main()
{
    int a1 =7;
    
    // get(5);

    // get(a1);
    printData(5);
    printData(std::mov(a1));
    return 0;
}
--------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <iterator>
#include <functional>
#include <cctype>

using namespace std;

bool isVaildChar(char c)
{
    return (!isalpha(c));
}

int main()
{
    string word ="Hel00!, h0w @re y0u?";
    string others;
    
    auto itr= remove_if(begin(word),end(word),&isVaildChar);
    cout<<word<<"\n";
    
    word.erase(itr,end(word));
    cout<<word<<"\n";
    
    word ="Hel00!, h0w @re y0u?";
    
    remove_copy_if(begin(word),end(word),back_inserter(others),&isVaildChar);
    
    cout<<others;
    
    return 0;
}
-------------------------------------- transform

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <iterator>
#include <functional>
#include <cctype>

using namespace std;

string toLowerCase(const string& s)
{
    string temp;
    std::transform(begin(s),end(s),back_insert_iterator<string>(temp),[](unsigned char c)
    {
        return tolower(c);
    });
    return temp;
}

template<typename T>
void printData(const T& dat)
{
    for(const auto& a: dat)
    {
        cout<<a<<" ";
    }
}
int main()
{
    vector<int> numbers{1,2,6,12,48,1,4,2,10,54,12};
    vector<string> words{"Hello","hello","zebra","x-ray","apple","123","Apple"};
    
    auto it = is_sorted_until(begin(numbers),end(numbers));
    
    cout<<"number is sorted for "<<distance(begin(numbers),it)<<" element\n";
    
    cout<<boolalpha;
    
    cout<<is_sorted(begin(numbers),end(numbers))<<"\n";
    
    
    sort(begin(numbers),end(numbers));
    
    sort(begin(words),end(words));
    
    printData<vector<int>>(numbers);
    
    cout<<"\n";
    
    printData<vector<string>>(words);
    
    
    sort(begin(words),end(words),[](string s1,string s2)
    {
        return toLowerCase(s1) < toLowerCase(s2);
    });
    
    cout<<"\n";
    
    printData<vector<string>>(words);
    return 0;
}
---------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;


template <typename T>
struct sum {
    T value;

    template <typename ... Ts>
    sum(Ts&& ... values)  : value{(values + ...)} {}
   
};

template <typename ... Ts>
sum(Ts&& ... ts) -> sum<std::common_type_t<Ts...>>;
int main()
{
    sum s          {1u, 2.0, 3, 4.0f};
    sum string_sum {std::string{"abc"}, "def"};


    std::cout << s.value          << '\n'
              << string_sum.value << '\n';
    return 0;
}
------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;

template<typename ... Ts>
auto sum(Ts... ts)
{
    return (ts + ...);
}

template <typename ... Ts>
auto product(Ts ... ts)
{
    return (ts * ... * 1);
}

int main()
{
    int the_sum {sum(1, 2, 3, 4, 5)}; // Value: 15
    
    
     std::string a {"Hello "};
     std::string b {"How r u?"};

     //std::cout << sum(a, b) << '\n'; // Output: Hello World
     
     string ssum{sum(a,b)};
      
    cout<<the_sum<<"\n";
    cout<<ssum;
    return 0;
}
-------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;

template<typename T, typename ... TS>
void addMulti(T& vec,TS ... ts)
{
    (vec.push_back(ts), ...);
}

template<typename ... TS>
void printAll(TS ... ts)
{
    ((cout<<ts), ...);
}
int main()
{
    std::vector<int> v {1, 2,3};
    
    addMulti(v,4,5,6,7,8,9,0);
    
    printAll<int>(4,5,6,7,8,9,0);
   
    return 0;
}
-------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

using namespace std;
template<typename T>
void printAll(const auto& data)
{
        for(const auto& a: data)
        {
                cout<<a<<" ";
        }
        cout<<"\n";
}
int main()
{
        vector<int> vec{5,2,3,6,1,9,4,8};

        printAll<vector<int>>(vec);

		/*
		what this nth_element() is doing?, it is giving us the value at nth position if the array or vecotr is sorted, so
		here we are requesting the 5th sorted element which is "5" so it placed the value 5 at 5th position. it tries to keep
		all the element smaller than 5 on the left side but wothout sorting and all the bigger element on the right sode of the 5
		but without sorting, so it is quicker then sort and we can get the element from its position.
		*/
        nth_element(begin(vec), begin(vec)+4,end(vec));


        printAll<vector<int>>(vec);
		
		/*
		here we are gettign second largest element without sorting as we used std::greater<int>() operator.
		so value 8 will be placed on the second position after 9 and that is the second highest element.
		*/

        nth_element(begin(vec),begin(vec)+1,end(vec),std::greater<int>());

        printAll<vector<int>>(vec);

        return 0;
}
------------------------ count vowels -------------
#include <iostream>
#include <algorithm>
using namespace std;
     
template<typename T,typename ...TS>
auto getCount(const T& range, TS ... ts)
{
    return (std::count(begin(range),end(range),ts)+ ...);
}

int main()
{
   
    cout<<getCount("abcdefghijklmnopqrstuvwxyz",'a','e','i','o','u');
    return 0;
}
---------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
     
template<typename T,typename ...TS>
auto getCount(const T& range, TS ... ts)
{
    // return (std::count(begin(range),end(range),ts)+ ...);
    auto sum =0;
    (for_each(begin(range),end(range),[=,&sum](const auto& s )
    {
        sum +=(std::count(begin(s),end(s),ts) + ...);
    }
    ));
    return sum;
}

int main()
{
   
    vector<string> vs{"bhargav","patel","kashyap","Priyanka","aeiou"};
    cout<<getCount(vs,'a','e','i','o','u');
    return 0;
}
---------------------------
#include <iostream>
#include <tuple>
using namespace std;

template<typename ... TS>
void print(TS ... ts)
{
    ((cout<<ts<<" "),...);
}

int main()
{
    char c;
    string s;
    int i;
    float f;
    std::tuple<char,string,int,float> tp;
    
    tp = make_tuple('a',"Bhargav",1,1.5);
    
    cout<<get<1>(tp);
    
    get<1>(tp) = "Patel";
    
    cout<<get<1>(tp)<<"\n";
    
    cout<<"tuple size :"<<tuple_size<decltype(tp)>::value<<"\n";
    
    
    std::tie(c,s,i,f) = tp;
    
    //cout<<c<<" "<<s<<" "<<i<<" "<<f;
    
    print(c,s,i,f);

    return 0;
}
------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

  #include <iostream>
  #include <variant>
  #include <list>
  #include <string>
  #include <algorithm>      

  using namespace std;

  class cat {
      string name;

  public:
      cat(string n) : name{n} {}
                void meow() const {
          cout << name << " says Meow!\n";
      }
  };
  
    class dog {
        string name;

      public:
      dog(string n) : name{n} {}

      void woof() const {
          cout << name << " says Woof!\n";
      }
  };
      
    using animal = variant<dog, cat>;
  template <typename T>
  bool is_type(const animal &a) {
      return holds_alternative<T>(a);
  }

int main()
{
 struct animal_voice
  {
      void operator()(const dog &d) const { d.woof(); }
      void operator()(const cat &c) const { c.meow(); }
  };
  
  list<animal> l {cat{"Tuba"}, dog{"Balou"}, cat{"Bobby"}};
  
  /* first method */
  for (const animal &a : l) {
              switch (a.index()) {
              case 0: 
                  get<dog>(a).woof();
                  break;
              case 1:
                  get<cat>(a).meow();
                  break;
              }
          }
          cout << "-----\n";
  /**/
  
  /*second method */
  
    for (const animal &a : l) {
      if (const auto d (get_if<dog>(&a)); d) {
          d->woof();
      } else if (const auto c (get_if<cat>(&a)); c) {
          c->meow();
      }
  }
  cout << "-----\n";
  /**/
       
 /* third method */      
 for (const animal &a : l) {
      visit(animal_voice{}, a);
  }
  cout << "-----\n";
  /**/

    return 0;
}
-------------------------------------
#include <cstdio>
#include <iostream>
#include <tuple>
using namespace std;

template<typename... Ts>
auto sum(std::tuple<Ts...> const& theTuple)
{
    auto sumData = 0;
    std::apply
    (
        [&sumData](Ts const&... tupleArgs)
        {
            sumData = (tupleArgs + ...);
        }, theTuple
    );
    return sumData;
}

int main()
{
     // advanced example
    std::tuple myTuple{1,2,3,4,5,6,7,8,9,10};
    cout<<sum( myTuple )<< '\n';
}
-------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <cstdio>
#include <iostream>
#include <tuple>
using namespace std;

template<typename... Ts>
void sum(std::tuple<Ts...> const& theTuple)
{
    
    std::apply
    (
        [](Ts const&... tupleArgs)
        {
            ((cout<<tupleArgs<<" "), ...);
        }, theTuple
    );
}

int main()
{
     // advanced example
    std::tuple myTuple{1,2,3,4,5,6,7,8,9,10};
    sum( myTuple );
}
---------------------------


/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <tuple>
#include <utility>
using namespace std;

using TupData = tuple<int, double, char>;
template<typename T>
class processingContext_c
{
  tuple<T> _data;
  public:
  template<typename T1>
  processingContext_c(T1&& d):_data(std::forward<T1> (d))
  {
      
  }
  
  
};


struct p1{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data),...);
        //std::tie(i,d,c)= data;
    }
};
int main()
{
    tuple<int, double, char> t{1,3.4,'c'};
    
    
    processingContext_c<TupData> p{t};
    
    std::apply(p1{},t);
    return 0;
}
------------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <tuple>
#include <utility>
#include <functional>
using namespace std;

using TupData = tuple<int, double, char>;
template<typename T>
class processingContext_c
{
  tuple<T> _data;
  using invocable_t = std::function< void(T) >;

  std::vector< invocable_t > _invocables;
  public:
  template<typename T1>
  processingContext_c(T1&& d):_data(std::forward<T1> (d))
  {
      
  }
  
  template< typename T1, typename... ARGS >
  void addFunction(ARGS &&...args )
  {
       _invocables.emplace_back(  T1{ std::forward< ARGS >( args )... } );
  }
 
  
    void execute() const
    {
      
      for ( auto const &invocable : _invocables )
      {
        std::apply(invocable, _data);
      }
    }
  
  
};

struct p1{
    template<typename T>
    void operator()(T data)
    {
        int i;
        double d;
        char c;
        //TupData t = data...;
        // ((cout<<data<<" "),...);
        std::tie(i,d,c)= data;
        cout<<i<<d<<c<<"\n";
    }
};

struct p2{
    template<typename ARGS>
    void operator()(ARGS data)
    {
        int i;
        double d;
        char c;
        //((cout<<data<<"+"),...);
        std::tie(i,d,c)= data;
        
        cout<<i<<" "<<d<<" "<<c<<"\n";
    }
};

int main()
{
    tuple<int, double, char> t{1,3.4,'c'};
    
    
    processingContext_c<TupData> p{t};
    

    
    p.addFunction<p1>();
    
    p.addFunction<p2>();
    
    p.execute();
    
    //std::apply(p1{},t);
    return 0;
}

/*
struct p1{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data<<" "),...);
        //std::tie(i,d,c)= data;
    }
};

struct p2{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data<<"+"),...);
        //std::tie(i,d,c)= data;
    }
};
*/
-------------------------------------------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <algorithm>
#include <memory>
#include <vector>

using namespace std;

class train
{
    string name;
    public:
    train(string st) : name(st)
    {
        
    }
    string get()
    {
        return name;
    }
};

class track
{
    string name;
    public:
    track(string st) : name(st)
    {
        
    }
    string get()
    {
        return name;
    }
};


class station
{
    string name;
    public:
    station(string st) : name(st)
    {
        
    }
    string get()
    {
        return name;
    }
};

----------------------------------------------------
 /* observer pattern */ 
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <algorithm>
#include <memory>
#include <vector>

using namespace std;

class weatherInterface_c
{

  public:
  virtual void operator()(int temp,int hum,int airspeed) = 0;
  virtual ~weatherInterface_c() = default;
  
  protected:
  weatherInterface_c() = default;
  weatherInterface_c( const weatherInterface_c & ) = delete;
  weatherInterface_c &operator=( const weatherInterface_c & ) = delete;
  weatherInterface_c( weatherInterface_c && ) = default;
  weatherInterface_c &operator=( weatherInterface_c && ) = default;
  
};

class BarodaWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Baroda \n";
        cout<<"Temprature:"<<temp<<" Humidity:"<<hum<<" air speed:"<<airspeed<<"\n";
    }
};

class PuneWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Pune \n";
        cout<<"Temprature:"<<temp<<" Humidity:"<<hum<<" air speed:"<<airspeed<<"\n";
    }
};

class DelhiWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Delhi \n";
        cout<<"Good air quality as air speed:"<<airspeed<<" will take away all air polution\n";
    }
};

template< typename TYPE >
class WeatherData_c
{
    public:
    vector<std::unique_ptr< TYPE >> _processor;
    
    template<typename ... ARGS>
    void prapogate(ARGS ... args)
    {
        for(const auto& subProc: _processor)
        {
            subProc->operator()(forward<ARGS>(args)...);
        }
    }
    
    template< typename PROCESSOR_TYPE, typename... PROCESSOR_ARGS >
    void create(PROCESSOR_ARGS &&...args )
    {
      _processor.emplace_back(std::make_unique< PROCESSOR_TYPE >( std::forward< PROCESSOR_ARGS >( args )... ) );
    }
    
};

class allIndia_c:WeatherData_c< weatherInterface_c >
{
    public:
    void fun(int a,int b,int c)
    {
        create<BarodaWeatherStation_c>();
        create<PuneWeatherStation_c>();
        create<DelhiWeatherStation_c>();
        prapogate(a,b,c);
    }
};

int main()
{
    
   allIndia_c c;
    
   c.fun(4,5,6);

   return 0;
}
-------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <algorithm>
#include <memory>
#include <vector>

using namespace std;

class weatherInterface_c
{

  public:
  virtual void operator()(int temp,int hum,int airspeed) = 0;
  virtual ~weatherInterface_c() = default;
  
  protected:
  weatherInterface_c() = default;
  weatherInterface_c( const weatherInterface_c & ) = delete;
  weatherInterface_c &operator=( const weatherInterface_c & ) = delete;
  weatherInterface_c( weatherInterface_c && ) = default;
  weatherInterface_c &operator=( weatherInterface_c && ) = default;
  
};

class BarodaWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Baroda \n";
        cout<<"Temprature:"<<temp<<" Humidity:"<<hum<<" air speed:"<<airspeed<<"\n";
    }
};

class PuneWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Pune \n";
        cout<<"Temprature:"<<temp<<" Humidity:"<<hum<<" air speed:"<<airspeed<<"\n";
    }
};

class DelhiWeatherStation_c : public weatherInterface_c
{
    public:
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Delhi \n";
        cout<<"Good air quality as air speed:"<<airspeed<<" will take away all air polution\n";
    }
};

class BombayWeatherStation_c : public weatherInterface_c
{
    int i;
    public:
    BombayWeatherStation_c(int ii):i(ii)
    {
        
    }
    void operator()(int temp,int hum,int airspeed) 
    {
        cout<<"Weather of Bombay \n";
        cout<<"Temprature due to Humidity is:"<<i*temp<<"\n";
    }
};

template< typename TYPE >
class WeatherData_c
{
    public:
    vector<std::unique_ptr< TYPE >> _processor;
    
    template<typename ... ARGS>
    void prapogate(ARGS ... args)
    {
        for(const auto& subProc: _processor)
        {
            subProc->operator()(forward<ARGS>(args)...);
        }
    }
    
    template< typename PROCESSOR_TYPE, typename... PROCESSOR_ARGS >
    void create(PROCESSOR_ARGS &&...args )
    {
      _processor.emplace_back(std::make_unique< PROCESSOR_TYPE >( std::forward< PROCESSOR_ARGS >( args )... ) );
    }
    
};

class allIndia_c:WeatherData_c< weatherInterface_c >
{
    public:
    void fun(int a,int b,int c)
    {
        create<BarodaWeatherStation_c>();
        create<PuneWeatherStation_c>();
        create<DelhiWeatherStation_c>();
        create<BombayWeatherStation_c>(7);
        prapogate(a,b,c);
    }
};

class weatherUpdate_c
{
   allIndia_c c;
   
   public:
   void newDataUpdate(int temp,int hum, int airspeed)
   {
        cout<<"New Data is available --------->\n";  
        c.fun(temp,hum,airspeed);
        cout<<"end of all weather station update --------->\n\n\n\n";  
   }
};
int main()
{
    
  weatherUpdate_c wuc;
  wuc.newDataUpdate(4,5,6);
  wuc.newDataUpdate(7,8,9);
  
   return 0;
}
-----------------------

/******************************************************************************

operator() overloaded

*******************************************************************************/
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

class weatherInterface
{
  public:
  virtual void operator()(int i,int j,int k) = 0;
  virtual void operator()(int i) = 0;
};

class BarodaWeather:public weatherInterface
{
    public:
    void operator()(int i,int j,int k)
    {
        cout<<"Baroda update ......\n";
        cout<<"temprature: "<<i<<" Humidity: "<<j<<" wind speed: "<<k<<"\n";
    }
    void operator()(int i)
    {
        cout<<"Baroda update 2......\n";
    }
    
};

class puneWeather:public weatherInterface
{
    public:
    void operator()(int i,int j,int k)
    {
        cout<<"Pune update ......\n";
        cout<<"Moiture level: "<<i*j<<"\n";
        cout<<"wind speed: "<<k<<"\n";
    }
    void operator()(int i)
    {
        cout<<"Pune update 2......\n";
    }
    
};

class DelhiWeather:public weatherInterface
{
    public:
    void operator()(int i,int j,int k)
    {
        cout<<"Delhi update ......\n";
        cout<<"wind speed: "<<k<<"\n";
    }
    void operator()(int i)
    {
        cout<<"Delhi update 2......\n";
    }
    
};


template<typename T>
class stationInterface
{
  public:  
  vector< unique_ptr<T> > _ptrVec;
  
  
  template<typename weatherStation,typename ... WeatherPara>
  void create(WeatherPara ... wp)
  {
      _ptrVec.emplace_back( std::make_unique<weatherStation>(std::forward<WeatherPara>(wp)...));
  }
  
  
  
  
  template<typename ... ARGS>
  void process(ARGS ... args)
  {
      for(const auto& data: _ptrVec)
      {
          data->operator()(std::forward<ARGS>(args)...);
      }
  }
  
  template<typename ... ARGS>
  void process2(ARGS ... args)
  {
      for(const auto& data: _ptrVec)
      {
          data->operator()(std::forward<ARGS>(args)...);
      }
  }
};

class stations:public stationInterface< weatherInterface >
{
    public:
    void fun(int a,int b,int c)
    {
        create<BarodaWeather>();
        create<puneWeather>();
        create<DelhiWeather>();
        process(a,b,c);
        
        process2(a);
    }
};

int main()
{
   stations st;
   st.fun(4,5,6);
   st.fun(9,1,16);
  
   return 0;
}
-------------
unstable partition based on predicate
// Online C++ compiler to run C++ program online
#include <iostream>
#include <functional>
#include <iterator>
#include <cctype>
#include <algorithm>
using namespace std;

int main() {
   std::function<bool (unsigned char)> pred = [](unsigned char c) -> bool{
       return isupper(c);
   };

    string s = "Tarak Mehta Ka Oolta Chasma";
    
    if(!is_partitioned(begin(s),end(s),pred ))
    {
        partition( begin(s),end(s),pred );
    }
    
    cout<<"string now\n";
    cout<<s<<"\n";
    
    auto part = partition_point( begin(s),end(s),pred );
    
    cout<<"true part\n";
    
    copy(begin(s), part, ostream_iterator<char>(cout," "));
    cout<<"\n";
    cout<<"false part\n";
    
    copy( part, end(s), ostream_iterator<char>(cout," "));
    
    return 0;
}
---------------------------------------------------------------
/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <string>
#include <numeric>

using namespace std;

int main()
{
    string s = "This is some text, with some characters."\
    "Not every characters is letter, some like this one '3' is number";
    
    vector<int> number(100);
    iota(begin(number),end(number),1);
    
    
    auto it = find(begin(s),end(s),',');
    
    cout<<"pos is: "<<distance(begin(s),it)<<"\n";
    
    auto itr = begin(number);
    while(itr != end(number))
    {
        itr = find_if(itr, end(number), [](int a)
        {
            return ( a%3 == 0  &&  a%5 == 0);
        });
        
        
    
        if( itr != end(number))
        {
            cout<<" and value is "<<*itr<<"\n";
            advance(itr,1);
        }
    }

    return 0;
}
-------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <string>
#include <numeric>
#include <functional>

using namespace std;
/* Third arugment is default funciton if no predicate function is provided*/

auto searchSring(const string& ref,
                 const string& s,
                 function<bool(unsigned char , unsigned char)> pred =
                 std::equal_to<unsigned char>())
                 {
                    return search(begin(ref),end(ref),begin(s),end(s),pred);   
                 }


std::function<bool(unsigned char, unsigned char)> equal_ignor_case =

[](unsigned char rc, unsigned char sc) -> bool{
    return tolower(rc) == tolower(sc);
};

int main()
{
    string dna = "GTAAATCTAGGATCATAATAATCATAAAT";
    string text = "my name is BharGav PaTel";
    
    auto it = searchSring(dna, "CTAGGA");
    
    if( it != end(dna) )
    {
        cout<<distance(cbegin(dna),it)<<"\n";
    }


    it = searchSring(text, "bhargav",equal_ignor_case);
    
    if( it != end(text) )
    {
        cout<<distance(cbegin(dna),it)<<"\n";
    }
    return 0;
}
----------------------------------------
#include <iostream>
#include <vector>
#include <cmath>
#include <iterator>
#include <algorithm>


using namespace std;

int main()
{
    vector<double> d{1.1, -0.5, 3.4, -5.5, 6.7, 8.9 };
    
    auto it = min_element( begin(d), end(d) );
    
    cout<<*it<<"\n";


    it = min_element( begin(d), end(d) , []( const double& d1, const double& d2)
    {
        return abs(d1) < abs(d2);
    });
    
    cout<<*it<<"\n";
    
    vector<string> s{"BHARGAV", "patel"};
    
    cout<<min("BHARGAV"s, "patel"s , []( const string& d1, const string& d2)
    {
        return (d1.size() < d2.size());
    });
    
    return 0;
}
--------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/


#include <iostream>
using namespace std;
class interface {

  public:    
    // overload function call/parentheses operator
    virtual void operator()(int i)  = 0;
};

class A :public interface{

  public:    
    // overload function call/parentheses operator
    void operator()(int i) {
      cout << "Hello World! -->"<<i<<"\n";
    }
};

class B :public interface{

  public:    
    // overload function call/parentheses operator
    void operator()(int i) {
      cout << i*i<<"\n";
    }
};

int main() {

  // create an object of Greet class
  A a;

  // call the object as a function
  int i =9;
  a(i);
  
  B b;
  
  b(i);

  return 0;
}

/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

class Weatherinterface
{
    public:
    virtual void operator()(int i, int j,int k)=0;
};

class baroda:public Weatherinterface
{
    public:
    void operator()(int i, int j,int k)
    {
        cout<<"Baroda ="<<i*j*k;
    }
};

class pune:public Weatherinterface
{
    public:
    void operator()(int i, int j,int k)
    {
        cout<<"Pune ="<<i+j+k;
    }
};

template<typename T>
class weathercal
{
    vector<unique_ptr<T>> vecData;
    public:
    
    template<typename T1,typename ... ARGS>
    void create(ARGS&& ... args)
    {
        vecData.emplace_back(std::make_unique<T1>(std::forward<ARGS>(args) ...));
    }
    
    // template<typename T1,typename ... ARGS>
    // void update(ARGS ... args)
    // {
    //     for(const auto& obj: vecData)
    //     {
    //         obj->operator()(std::forward(args)...); <-- my mistake that <ARGS> is not added in std::forwrd<ARGS>(args)...
    //     }
    // }
    void printData()
    {
        cout<<vecData.size();
    }
    
    // template<typename T1,typename T2, typename T3>
    // void update(T1 i,T2 j,T3 k)
    // {
    //     for(const auto& obj: vecData)
    //     {
    //         obj->operator()(i,j,k);
    //     }
    // }
    
    template<typename ... ARGS>
    void prapogate(ARGS ... args)
    {
        for(const auto& subProc: vecData)
        {
            subProc->operator()(forward<ARGS>(args)...);
        }
    }
};
int main()
{
   
    
    weathercal<baroda> obj1;
    obj1.create<baroda>();
    
    int i=4;
    int j=5;
    int k=6;
    // obj1.update<baroda>(i,j,k);
    obj1.printData();
    //obj1.update(i,j,k);
    obj1.prapogate(i,j,k);
    return 0;
}
---------------------------
#include <iostream>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#define TRANSACT 100000
using namespace std;


void deposit(int& account,mutex& m)
{
    for(int i=0; i<TRANSACT ; ++i )
    {
        lock_guard<mutex> lock(m);
        ++account;
    }
}

void withdraw(int& account,mutex& m)
{
     for(int i=0; i<TRANSACT ; ++i )
     {
        lock_guard<mutex> lock(m);
        --account;
     }
}

int main()
{
    auto threads = thread::hardware_concurrency();
    mutex m;
    
    cout<<threads<<"\n";
    
    int account  = 0;
    
    thread t1(deposit, std::ref(account),std::ref(m));
    thread t2(withdraw,std::ref(account),std::ref(m));
    
    t1.join();
    t2.join();
    
    cout<<"account value: "<<account<<"\n";
    return 0;
}
----------------------
/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/

#include <iostream>
#include <algorithm>
#include <shared_mutex>
#include <chrono>
#include <thread>

using namespace std;

struct DataSource
{
  private:
    shared_mutex mut;
    int value =0;
  public:
  DataSource() = default;
  int get()
  {
      shared_lock lock(mut);
      cout<<"getting value: "<<value<<"\n";
      return value;
  }
  
  void set(int v)
  {
      unique_lock lock(mut);
      value = v;
      cout<<"setting value:"<<value<<"\n";
  }
  
};


void readWorker(DataSource& ds)
{
    while(true)
    {
        ds.get();
        this_thread::sleep_for(500ms);
    }
}

void writeWorker(DataSource& ds)
{
    while(true)
    {
        auto i=ds.get();
        ds.set(i+1);
        this_thread::sleep_for(2s);
    }
}
int main()
{
   DataSource d;
   thread writeThread(&writeWorker, std::ref(d));
   
   
   for(int i=0; i<20; ++i)
   {
       thread t(&readWorker, std::ref(d));
       t.detach();
   }
   
   writeThread.join();
   return 0;
}
---------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <string>
#include <memory>

using namespace std;

class student
{
  int id;
  string first;
  string last;
public:
 student(int i,const string& f,const string& l):id(i),first(f),last(l)
 {
     
 }
 student() = default;
 ~student()
 {
     cout<<"Delete studnet\n";
 }
 int getID()
 {
     return id;
 }
 
 const string& getFirst() const
 {
     return first;
 }
 
 const string& getLast() const
 {
     return last;
 }
};


class studentDeleter
{
  public:
  void operator()(student *s)
  {
      cout<<"deleting the obj: "<<s->getFirst()<<"\n";
      delete s;
  }
};

int main()
{
    string first = "Bhargav";
    string last  = "Patel";
    unique_ptr<student> s1(new student(1,first,last));
    
    unique_ptr<student> s2 = make_unique<student>(2,"kashyap","patel");
    
    unique_ptr<student> s3 = make_unique<student>();
    
    
    studentDeleter sd;
    
    student* obj = new student(4,"abc","xyz");
    
    unique_ptr<student, studentDeleter> sdobj(obj, sd);
    
    unique_ptr<student> p = nullptr;
    

    return 0;
}
-------------------