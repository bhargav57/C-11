#include <iostream>

using namespace std;

template<typename T>
class container
{
    T d;
    public:
    explicit container(T data):d(data)
    {
        
    }
    friend std::ostream& operator<<(std::ostream& os,const container<T>& data)
    {
        return (os<<data.d);
    }
};

int main()
{
    container<int> c(100);
    container<string> a("ABC");
    cout<<c<<" "<<a;

    return 0;
}
---------------
#include <iostream>

using namespace std;
template<typename T>
class shrdPtr
{
    T *p;
    public:
    shrdPtr(T *d):p(d)
    {
        
    }
    ~shrdPtr()
    {
        cout<<"destructor\n";
        delete p;
    }
    T& operator*()
    {
        return *p;
    }
};

int main()
{
    int* p= new int(10);
    shrdPtr<int> sp(p);
    cout<<*p;
    
    *p= 20;
    
    cout<<*p;
    
    return 0;
}
----------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;


int main()
{
    vector<int> v{1,2,3,4,5,6,7,8,9,10};   

    vector<int> out;
    
    copy(begin(v),end(v),ostream_iterator<int>(cout,"+"));
    
    
    copy_if(begin(v),end(v),back_inserter(out),[](int i){return i%2==0;});
    
    
    copy(begin(out),end(out),ostream_iterator<int>(cout," "));

    
    return 0;
}
-----------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;
template<typename T>
void printData(T data)
{
    for(auto a: data)
    {
        cout<<a<<"\n";
    }
}

int main()
{
    vector<int> v{1,2,3,4,5,6,7,8,9,10};   

    vector<int> out;
    
    copy(begin(v),end(v),ostream_iterator<int>(cout,"+"));
    
    
    copy_if(begin(v),end(v),back_inserter(out),[](int i){return i%2==0;});
    
    
    copy(begin(out),end(out),ostream_iterator<int>(cout," "));

    printData<vector<int>>(out);
    
    
    for_each(begin(out),end(out),[](int a){cout<<a;});
    return 0;
}
--------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>

using namespace std;
class student
{
    
    public:
    string name;
    int id;
    student(string iname, int iid):name(iname), id(iid)
    {
        
    }
    
};

int main()
{
   
   student s1("abc",1);
   student s2("efg",2);
   student s3("hij",3);
   
   vector<student> vs1{s1,s2,s3};
   
   
   student a1("abc",1);
   student a2("efg1",2);
   student a3("hij1",3);
   
   vector<student> vs2{a1,a2,a3};
   
   
  std::function<bool(const student&, const student&)> id_equal = [](const student& s1, const student& s2)
  {
      return (s1.id == s2.id);
  };
  
  std::function<bool(const student&, const student&)> compare_all = [](const student& s1, const student& s2)
  {
      return ((s1.id == s2.id) &&
              (s1.name == s2.name));
  };
  
  
//   std::function<bool(const student&, const student&)> id_only =
//                 [](const student& s1,const student& s2){
//                         return s1.id == s2.id;
//                 };
  cout<<boolalpha;
  
  auto e = equal(begin(vs1),end(vs1),begin(vs2),id_equal);
  
  cout<<e<<"\n";
  
  e = equal(begin(vs1),end(vs1),begin(vs2),compare_all);
  
  cout<<e;
   
  return 0;
}
----------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>

using namespace std;

int main()
{
   
  vector<string> fruits{"apple","mango","almond","berry"}; 
  cout<<boolalpha;
  
 
   
//   auto e = find_if(begin(fruits),end(fruits),[](string s){return s=="almond";});
   
//   cout<<*e;

   auto cmpfun = [](string s)
                    {
                        return s=="almond";
                    };
   auto e = find_if(begin(fruits),end(fruits),cmpfun);
   
   cout<<*e;
   return 0;
}
-----------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

using namespace std;



int main()
{
    
    vector<unique_ptr<int>> ptr;
    
    for(int i=0; i<10; i++)
    {
        unique_ptr temp= make_unique<int>();
        *temp = i;
        ptr.push_back(std::move(temp));
    }
    
    for_each(begin(ptr),end(ptr),[](const unique_ptr<int>& p1)
    {
        cout<<*p1<<" ";
    });
    
    vector<unique_ptr<int>> movedPtr;
    
    move(begin(ptr),end(ptr),back_inserter(movedPtr));
    
    cout<<boolalpha<<"\n";
    for_each(begin(movedPtr),end(movedPtr),[](const unique_ptr<int>& p1)
    {
        cout<<(p1 == nullptr)<<"\n";
    });
    return 0;
}

/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <utility>
using namespace std;

void get(int& a)
{
    cout<<"[L value]\n";
}

void get(const int& a)
{
    cout<<"[R value]\n";
}

template<typename T>
void AsperTheArg(T&& x)
{
    cout<<"here\n";
    get(x);
    get(std::forward<T>(x));
}

int main()
{
    
    int a1 =5;
    
    // get(a1);
    
    // get(7);
    
    AsperTheArg(a1);
    AsperTheArg(7);
    return 0;
}
-----------------------------
#include <iostream>
#include <utility>
using namespace std;

void get(int& a)
{
    cout<<"[L value]\n";
}

void get(const int& a)
{
    cout<<"[R value]\n";
}

template<typename A>
void AsperTheArg(A&& x)
{
    cout<<"here\n";
    //get(x);
    get(std::forward<A>(x));
}

int main()
{
    
    int a1 =5;
    
    // get(a1);
    
    // get(7);
    
    AsperTheArg(a1);
    AsperTheArg(7);
    return 0;
}
--------
#include <iostream>

using namespace std;


void get(int& a)
{
    cout<<"[l value]\n";
}
void get(const int& a)
{
    cout<<"[r value]\n";
}

// template<typename T>
// void printData(T&& d)//&& aftet template parameter is known as a universal reference as it is template and type deduction is required.
// {
//     //get(d);
//     get(std::forward<T>(d));
// }


void printData(int&& d)//&& after the specific type is consider as a r-value because no type deduction is needed as it is sepcified here.
{
    //get(d);
    get(std::forward<int>(d));
}

int main()
{
    int a1 =7;
    
    // get(5);

    // get(a1);
    printData(5);
    printData(std::mov(a1));
    return 0;
}
--------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <iterator>
#include <functional>
#include <cctype>

using namespace std;

bool isVaildChar(char c)
{
    return (!isalpha(c));
}

int main()
{
    string word ="Hel00!, h0w @re y0u?";
    string others;
    
    auto itr= remove_if(begin(word),end(word),&isVaildChar);
    cout<<word<<"\n";
    
    word.erase(itr,end(word));
    cout<<word<<"\n";
    
    word ="Hel00!, h0w @re y0u?";
    
    remove_copy_if(begin(word),end(word),back_inserter(others),&isVaildChar);
    
    cout<<others;
    
    return 0;
}
-------------------------------------- transform

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <iterator>
#include <functional>
#include <cctype>

using namespace std;

string toLowerCase(const string& s)
{
    string temp;
    std::transform(begin(s),end(s),back_insert_iterator<string>(temp),[](unsigned char c)
    {
        return tolower(c);
    });
    return temp;
}

template<typename T>
void printData(const T& dat)
{
    for(const auto& a: dat)
    {
        cout<<a<<" ";
    }
}
int main()
{
    vector<int> numbers{1,2,6,12,48,1,4,2,10,54,12};
    vector<string> words{"Hello","hello","zebra","x-ray","apple","123","Apple"};
    
    auto it = is_sorted_until(begin(numbers),end(numbers));
    
    cout<<"number is sorted for "<<distance(begin(numbers),it)<<" element\n";
    
    cout<<boolalpha;
    
    cout<<is_sorted(begin(numbers),end(numbers))<<"\n";
    
    
    sort(begin(numbers),end(numbers));
    
    sort(begin(words),end(words));
    
    printData<vector<int>>(numbers);
    
    cout<<"\n";
    
    printData<vector<string>>(words);
    
    
    sort(begin(words),end(words),[](string s1,string s2)
    {
        return toLowerCase(s1) < toLowerCase(s2);
    });
    
    cout<<"\n";
    
    printData<vector<string>>(words);
    return 0;
}
---------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;


template <typename T>
struct sum {
    T value;

    template <typename ... Ts>
    sum(Ts&& ... values)  : value{(values + ...)} {}
   
};

template <typename ... Ts>
sum(Ts&& ... ts) -> sum<std::common_type_t<Ts...>>;
int main()
{
    sum s          {1u, 2.0, 3, 4.0f};
    sum string_sum {std::string{"abc"}, "def"};


    std::cout << s.value          << '\n'
              << string_sum.value << '\n';
    return 0;
}
------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;

template<typename ... Ts>
auto sum(Ts... ts)
{
    return (ts + ...);
}

template <typename ... Ts>
auto product(Ts ... ts)
{
    return (ts * ... * 1);
}

int main()
{
    int the_sum {sum(1, 2, 3, 4, 5)}; // Value: 15
    
    
     std::string a {"Hello "};
     std::string b {"How r u?"};

     //std::cout << sum(a, b) << '\n'; // Output: Hello World
     
     string ssum{sum(a,b)};
      
    cout<<the_sum<<"\n";
    cout<<ssum;
    return 0;
}
-------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>
#include <iterator>
using namespace std;

template<typename T, typename ... TS>
void addMulti(T& vec,TS ... ts)
{
    (vec.push_back(ts), ...);
}

template<typename ... TS>
void printAll(TS ... ts)
{
    ((cout<<ts), ...);
}
int main()
{
    std::vector<int> v {1, 2,3};
    
    addMulti(v,4,5,6,7,8,9,0);
    
    printAll<int>(4,5,6,7,8,9,0);
   
    return 0;
}
-------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

using namespace std;
template<typename T>
void printAll(const auto& data)
{
        for(const auto& a: data)
        {
                cout<<a<<" ";
        }
        cout<<"\n";
}
int main()
{
        vector<int> vec{5,2,3,6,1,9,4,8};

        printAll<vector<int>>(vec);

		/*
		what this nth_element() is doing?, it is giving us the value at nth position if the array or vecotr is sorted, so
		here we are requesting the 5th sorted element which is "5" so it placed the value 5 at 5th position. it tries to keep
		all the element smaller than 5 on the left side but wothout sorting and all the bigger element on the right sode of the 5
		but without sorting, so it is quicker then sort and we can get the element from its position.
		*/
        nth_element(begin(vec), begin(vec)+4,end(vec));


        printAll<vector<int>>(vec);
		
		/*
		here we are gettign second largest element without sorting as we used std::greater<int>() operator.
		so value 8 will be placed on the second position after 9 and that is the second highest element.
		*/

        nth_element(begin(vec),begin(vec)+1,end(vec),std::greater<int>());

        printAll<vector<int>>(vec);

        return 0;
}
------------------------ count vowels -------------
#include <iostream>
#include <algorithm>
using namespace std;
     
template<typename T,typename ...TS>
auto getCount(const T& range, TS ... ts)
{
    return (std::count(begin(range),end(range),ts)+ ...);
}

int main()
{
   
    cout<<getCount("abcdefghijklmnopqrstuvwxyz",'a','e','i','o','u');
    return 0;
}
---------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
     
template<typename T,typename ...TS>
auto getCount(const T& range, TS ... ts)
{
    // return (std::count(begin(range),end(range),ts)+ ...);
    auto sum =0;
    (for_each(begin(range),end(range),[=,&sum](const auto& s )
    {
        sum +=(std::count(begin(s),end(s),ts) + ...);
    }
    ));
    return sum;
}

int main()
{
   
    vector<string> vs{"bhargav","patel","kashyap","Priyanka","aeiou"};
    cout<<getCount(vs,'a','e','i','o','u');
    return 0;
}
---------------------------
#include <iostream>
#include <tuple>
using namespace std;

template<typename ... TS>
void print(TS ... ts)
{
    ((cout<<ts<<" "),...);
}

int main()
{
    char c;
    string s;
    int i;
    float f;
    std::tuple<char,string,int,float> tp;
    
    tp = make_tuple('a',"Bhargav",1,1.5);
    
    cout<<get<1>(tp);
    
    get<1>(tp) = "Patel";
    
    cout<<get<1>(tp)<<"\n";
    
    cout<<"tuple size :"<<tuple_size<decltype(tp)>::value<<"\n";
    
    
    std::tie(c,s,i,f) = tp;
    
    //cout<<c<<" "<<s<<" "<<i<<" "<<f;
    
    print(c,s,i,f);

    return 0;
}
------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

  #include <iostream>
  #include <variant>
  #include <list>
  #include <string>
  #include <algorithm>      

  using namespace std;

  class cat {
      string name;

  public:
      cat(string n) : name{n} {}
                void meow() const {
          cout << name << " says Meow!\n";
      }
  };
  
    class dog {
        string name;

      public:
      dog(string n) : name{n} {}

      void woof() const {
          cout << name << " says Woof!\n";
      }
  };
      
    using animal = variant<dog, cat>;
  template <typename T>
  bool is_type(const animal &a) {
      return holds_alternative<T>(a);
  }

int main()
{
 struct animal_voice
  {
      void operator()(const dog &d) const { d.woof(); }
      void operator()(const cat &c) const { c.meow(); }
  };
  
  list<animal> l {cat{"Tuba"}, dog{"Balou"}, cat{"Bobby"}};
  
  /* first method */
  for (const animal &a : l) {
              switch (a.index()) {
              case 0: 
                  get<dog>(a).woof();
                  break;
              case 1:
                  get<cat>(a).meow();
                  break;
              }
          }
          cout << "-----\n";
  /**/
  
  /*second method */
  
    for (const animal &a : l) {
      if (const auto d (get_if<dog>(&a)); d) {
          d->woof();
      } else if (const auto c (get_if<cat>(&a)); c) {
          c->meow();
      }
  }
  cout << "-----\n";
  /**/
       
 /* third method */      
 for (const animal &a : l) {
      visit(animal_voice{}, a);
  }
  cout << "-----\n";
  /**/

    return 0;
}
-------------------------------------
#include <cstdio>
#include <iostream>
#include <tuple>
using namespace std;

template<typename... Ts>
auto sum(std::tuple<Ts...> const& theTuple)
{
    auto sumData = 0;
    std::apply
    (
        [&sumData](Ts const&... tupleArgs)
        {
            sumData = (tupleArgs + ...);
        }, theTuple
    );
    return sumData;
}

int main()
{
     // advanced example
    std::tuple myTuple{1,2,3,4,5,6,7,8,9,10};
    cout<<sum( myTuple )<< '\n';
}
-------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <cstdio>
#include <iostream>
#include <tuple>
using namespace std;

template<typename... Ts>
void sum(std::tuple<Ts...> const& theTuple)
{
    
    std::apply
    (
        [](Ts const&... tupleArgs)
        {
            ((cout<<tupleArgs<<" "), ...);
        }, theTuple
    );
}

int main()
{
     // advanced example
    std::tuple myTuple{1,2,3,4,5,6,7,8,9,10};
    sum( myTuple );
}
---------------------------


/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <tuple>
#include <utility>
using namespace std;

using TupData = tuple<int, double, char>;
template<typename T>
class processingContext_c
{
  tuple<T> _data;
  public:
  template<typename T1>
  processingContext_c(T1&& d):_data(std::forward<T1> (d))
  {
      
  }
  
  
};


struct p1{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data),...);
        //std::tie(i,d,c)= data;
    }
};
int main()
{
    tuple<int, double, char> t{1,3.4,'c'};
    
    
    processingContext_c<TupData> p{t};
    
    std::apply(p1{},t);
    return 0;
}
------------------------------
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <tuple>
#include <utility>
#include <functional>
using namespace std;

using TupData = tuple<int, double, char>;
template<typename T>
class processingContext_c
{
  tuple<T> _data;
  using invocable_t = std::function< void(T) >;

  std::vector< invocable_t > _invocables;
  public:
  template<typename T1>
  processingContext_c(T1&& d):_data(std::forward<T1> (d))
  {
      
  }
  
  template< typename T1, typename... ARGS >
  void addFunction(ARGS &&...args )
  {
       _invocables.emplace_back(  T1{ std::forward< ARGS >( args )... } );
  }
 
  
    void execute() const
    {
      
      for ( auto const &invocable : _invocables )
      {
        std::apply(invocable, _data);
      }
    }
  
  
};

struct p1{
    template<typename T>
    void operator()(T data)
    {
        int i;
        double d;
        char c;
        //TupData t = data...;
        // ((cout<<data<<" "),...);
        std::tie(i,d,c)= data;
        cout<<i<<d<<c<<"\n";
    }
};

struct p2{
    template<typename ARGS>
    void operator()(ARGS data)
    {
        int i;
        double d;
        char c;
        //((cout<<data<<"+"),...);
        std::tie(i,d,c)= data;
        
        cout<<i<<" "<<d<<" "<<c<<"\n";
    }
};

int main()
{
    tuple<int, double, char> t{1,3.4,'c'};
    
    
    processingContext_c<TupData> p{t};
    

    
    p.addFunction<p1>();
    
    p.addFunction<p2>();
    
    p.execute();
    
    //std::apply(p1{},t);
    return 0;
}

/*
struct p1{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data<<" "),...);
        //std::tie(i,d,c)= data;
    }
};

struct p2{
    template<typename ...ARGS>
    void operator()(ARGS ... data)
    {
        int i;
        double d;
        char c;
        ((cout<<data<<"+"),...);
        //std::tie(i,d,c)= data;
    }
};
*/